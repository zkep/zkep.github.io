<!DOCTYPE html>
<html lang=zh-CN>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:description" content="Love Your Life">
    <meta property="og:type" content="website">
    <meta name="description" content="Love Your Life">
    <meta name="keyword"  content="zkep,go">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        代理模式 - zkep日常
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_28hi1hpxx24.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 6.0.0"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> zkep‘s blog </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="https://avatars.githubusercontent.com/u/36965534" />    
        </div>
        <div class="name">
            <i>zkep</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">静态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">单元测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go-Generate-%E5%AE%9E%E7%8E%B0-%E2%80%9C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E2%80%9D"><span class="toc-text">Go Generate 实现 “动态代理”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82"><span class="toc-text">需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-1"><span class="toc-text">单元测试</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> zkep‘s blog </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        代理模式
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2021-03-30 18:30:02</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#go" title="go">go</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <p>接下来会通过 golang 实现静态代理，我们无法比较方便的利用反射实现动态代理，但是我们可以利用 go generate 实现类似的效果，并且这样实现有两个比较大的好处，一个是有静态代码检查，我们在编译期间就可以及早发现问题，第二个是性能会更好。</p>
<span id="more"></span>

<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> design</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// IUser IUser</span></span><br><span class="line"><span class="keyword">type</span> IUser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Login(username, password <span class="type">string</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// User 用户</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Login 用户登录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> Login(username, password <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 不实现细节</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserProxy 代理类</span></span><br><span class="line"><span class="keyword">type</span> UserProxy <span class="keyword">struct</span> &#123;</span><br><span class="line">    user *User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewUserProxy NewUserProxy</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserProxy</span><span class="params">(user *User)</span></span> *UserProxy &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;UserProxy&#123;</span><br><span class="line">    user: user,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Login 登录，和 user 实现相同的接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *UserProxy)</span></span> Login(username, password <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// before 这里可能会有一些统计的逻辑</span></span><br><span class="line">    start := time.Now()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是原有的业务逻辑</span></span><br><span class="line">    <span class="keyword">if</span> err := p.user.Login(username, password); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// after 这里可能也有一些监控统计的逻辑</span></span><br><span class="line">    log.Printf(<span class="string">&quot;user login cost time: %s&quot;</span>, time.Now().Sub(start))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> design</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;testing&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/stretchr/testify/require&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserProxy_Login</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    proxy := NewUserProxy(&amp;User&#123;&#125;)</span><br><span class="line">    err := proxy.Login(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;password&quot;</span>)</span><br><span class="line">    require.Nil(t, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Go-Generate-实现-“动态代理”"><a href="#Go-Generate-实现-“动态代理”" class="headerlink" title="Go Generate 实现 “动态代理”"></a>Go Generate 实现 “动态代理”</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>动态代理相比静态代理主要就是为了解决生产力，将我们从繁杂的重复劳动中解放出来，正好，在 Go 中 Generate 也是干这个活的<br>如下面的代码所示，我们的 generate 会读取 struct 上的注释，如果出现 @proxy 接口名 的注释，我们就会为这个 struct 生成一个 proxy 类，同时实现相同的接口，这个接口就是在注释中指定的接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User 用户</span></span><br><span class="line"><span class="comment">// @proxy IUser</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>接来下我们会简单的实现这个需求，由于篇幅和时间的关系，我们会略过一些检查之类的代码，例如 User 是否真正实现了 IUser 这种情况。<br>代码有点长，主要思路:</p>
<p>读取文件, 获取文件的 ast 语法树</p>
<ul>
<li>通过 NewCommentMap 构建 node 和 comment 的关系</li>
<li>通过 comment 是否包含 @proxy 接口名 的接口，判断该节点是否需要生成代理类</li>
<li>通过 Lookup 方法找到接口</li>
<li>循环获取接口的每个方法的，方法名、参数、返回值信息</li>
<li>将方法信息，包名、需要代理类名传递给构建好的模板文件，生成代理类</li>
<li>最后用 format 包的方法格式化源代码</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> design</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;go/ast&quot;</span></span><br><span class="line">    <span class="string">&quot;go/format&quot;</span></span><br><span class="line">    <span class="string">&quot;go/parser&quot;</span></span><br><span class="line">    <span class="string">&quot;go/token&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;text/template&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">(file <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    fset := token.NewFileSet() <span class="comment">// positions are relative to fset</span></span><br><span class="line">    f, err := parser.ParseFile(fset, file, <span class="literal">nil</span>, parser.ParseComments)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取代理需要的数据</span></span><br><span class="line">    data := proxyData&#123;</span><br><span class="line">        Package: f.Name.Name,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建注释和 node 的关系</span></span><br><span class="line">    cmap := ast.NewCommentMap(fset, f, f.Comments)</span><br><span class="line">    <span class="keyword">for</span> node, group := <span class="keyword">range</span> cmap &#123;</span><br><span class="line">        <span class="comment">// 从注释 @proxy 接口名，获取接口名称</span></span><br><span class="line">        name := getProxyInterfaceName(group)</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取代理的类名</span></span><br><span class="line">        data.ProxyStructName = node.(*ast.GenDecl).Specs[<span class="number">0</span>].(*ast.TypeSpec).Name.Name</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从文件中查找接口</span></span><br><span class="line">        obj := f.Scope.Lookup(name)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类型转换，注意: 这里没有对断言进行判断，可能会导致 panic</span></span><br><span class="line">        t := obj.Decl.(*ast.TypeSpec).Type.(*ast.InterfaceType)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, field := <span class="keyword">range</span> t.Methods.List &#123;</span><br><span class="line">            fc := field.Type.(*ast.FuncType)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 代理的方法</span></span><br><span class="line">            method := &amp;proxyMethod&#123;</span><br><span class="line">                Name: field.Names[<span class="number">0</span>].Name,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取方法的参数和返回值</span></span><br><span class="line">            method.Params, method.ParamNames = getParamsOrResults(fc.Params)</span><br><span class="line">            method.Results, method.ResultNames = getParamsOrResults(fc.Results)</span><br><span class="line"></span><br><span class="line">            data.Methods = <span class="built_in">append</span>(data.Methods, method)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成文件</span></span><br><span class="line">    tpl, err := template.New(<span class="string">&quot;&quot;</span>).Parse(proxyTpl)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf := &amp;bytes.Buffer&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> err := tpl.Execute(buf, data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 go fmt 对生成的代码进行格式化</span></span><br><span class="line">    src, err := format.Source(buf.Bytes())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(src), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getParamsOrResults 获取参数或者是返回值</span></span><br><span class="line"><span class="comment">// 返回带类型的参数，以及不带类型的参数，以逗号间隔</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getParamsOrResults</span><span class="params">(fields *ast.FieldList)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        params     []<span class="type">string</span></span><br><span class="line">        paramNames []<span class="type">string</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, param := <span class="keyword">range</span> fields.List &#123;</span><br><span class="line">        <span class="comment">// 循环获取所有的参数名</span></span><br><span class="line">        <span class="keyword">var</span> names []<span class="type">string</span></span><br><span class="line">        <span class="keyword">for</span> _, name := <span class="keyword">range</span> param.Names &#123;</span><br><span class="line">            names = <span class="built_in">append</span>(names, name.Name)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(names) == <span class="number">0</span> &#123;</span><br><span class="line">            names = <span class="built_in">append</span>(names, fmt.Sprintf(<span class="string">&quot;r%d&quot;</span>, i))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        paramNames = <span class="built_in">append</span>(paramNames, names...)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数名加参数类型组成完整的参数</span></span><br><span class="line">        param := fmt.Sprintf(<span class="string">&quot;%s %s&quot;</span>,</span><br><span class="line">            strings.Join(names, <span class="string">&quot;,&quot;</span>),</span><br><span class="line">            param.Type.(*ast.Ident).Name,</span><br><span class="line">        )</span><br><span class="line">        params = <span class="built_in">append</span>(params, strings.TrimSpace(param))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strings.Join(params, <span class="string">&quot;,&quot;</span>), strings.Join(paramNames, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getProxyInterfaceName</span><span class="params">(groups []*ast.CommentGroup)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, commentGroup := <span class="keyword">range</span> groups &#123;</span><br><span class="line">        <span class="keyword">for</span> _, comment := <span class="keyword">range</span> commentGroup.List &#123;</span><br><span class="line">            <span class="keyword">if</span> strings.Contains(comment.Text, <span class="string">&quot;@proxy&quot;</span>) &#123;</span><br><span class="line">                interfaceName := strings.TrimLeft(comment.Text, <span class="string">&quot;// @proxy &quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> strings.TrimSpace(interfaceName)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成代理类的文件模板</span></span><br><span class="line"><span class="keyword">const</span> proxyTpl = <span class="string">`</span></span><br><span class="line"><span class="string">package &#123;&#123;.Package&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">type &#123;&#123; .ProxyStructName &#125;&#125;Proxy struct &#123;</span></span><br><span class="line"><span class="string"> child *&#123;&#123; .ProxyStructName &#125;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func New&#123;&#123; .ProxyStructName &#125;&#125;Proxy(child *&#123;&#123; .ProxyStructName &#125;&#125;) *&#123;&#123; .ProxyStructName &#125;&#125;Proxy &#123;</span></span><br><span class="line"><span class="string"> return &amp;&#123;&#123; .ProxyStructName &#125;&#125;Proxy&#123;child: child&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;&#123; range .Methods &#125;&#125;</span></span><br><span class="line"><span class="string">func (p *&#123;&#123;$.ProxyStructName&#125;&#125;Proxy) &#123;&#123; .Name &#125;&#125; (&#123;&#123; .Params &#125;&#125;) (&#123;&#123; .Results &#125;&#125;) &#123;</span></span><br><span class="line"><span class="string"> // before 这里可能会有一些统计的逻辑</span></span><br><span class="line"><span class="string"> start := time.Now()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> &#123;&#123; .ResultNames &#125;&#125; = p.child.&#123;&#123; .Name &#125;&#125;(&#123;&#123; .ParamNames &#125;&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> // after 这里可能也有一些监控统计的逻辑</span></span><br><span class="line"><span class="string"> log.Printf(&quot;user login cost time: %s&quot;, time.Now().Sub(start))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> return &#123;&#123; .ResultNames &#125;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123;&#123; end &#125;&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> proxyData <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 包名</span></span><br><span class="line">    Package <span class="type">string</span></span><br><span class="line">    <span class="comment">// 需要代理的类名</span></span><br><span class="line">    ProxyStructName <span class="type">string</span></span><br><span class="line">    <span class="comment">// 需要代理的方法</span></span><br><span class="line">    Methods []*proxyMethod</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// proxyMethod 代理的方法</span></span><br><span class="line"><span class="keyword">type</span> proxyMethod <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 方法名</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    <span class="comment">// 参数，含参数类型</span></span><br><span class="line">    Params <span class="type">string</span></span><br><span class="line">    <span class="comment">// 参数名</span></span><br><span class="line">    ParamNames <span class="type">string</span></span><br><span class="line">    <span class="comment">// 返回值</span></span><br><span class="line">    Results <span class="type">string</span></span><br><span class="line">    <span class="comment">// 返回值名</span></span><br><span class="line">    ResultNames <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> design</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/stretchr/testify/require&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_generate</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"> want := <span class="string">`package proxy</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    type UserProxy struct &#123;</span></span><br><span class="line"><span class="string">        child *User</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    func NewUserProxy(child *User) *UserProxy &#123;</span></span><br><span class="line"><span class="string">        return &amp;UserProxy&#123;child: child&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    func (p *UserProxy) Login(username, password string) (r0 error) &#123;</span></span><br><span class="line"><span class="string">        // before 这里可能会有一些统计的逻辑</span></span><br><span class="line"><span class="string">        start := time.Now()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        r0 = p.child.Login(username, password)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // after 这里可能也有一些监控统计的逻辑</span></span><br><span class="line"><span class="string">        log.Printf(&quot;user login cost time: %s&quot;, time.Now().Sub(start))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return r0</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">    got, err := generate(<span class="string">&quot;./proxy.go&quot;</span>)</span><br><span class="line">    require.Nil(t, err)</span><br><span class="line">    assert.Equal(t, want, got)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>
        <div id="lv-container"></div>
        <div class="giscus"></div>
    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <!-- <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span> -->
        Created By <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>  Theme <a target="_blank" rel="noopener" href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






</html>
